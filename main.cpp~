#include <Windows.h>
#include "SDL/include/SDL.h"
#include <gl/GL.h>
#include <gl/GLU.h>

#include <string>

#pragma comment(lib, "SDL.lib")
#pragma comment(lib, "SDLmain.lib")

bool done = false;
Uint32 time;
Uint32 secondTime;
GLuint texture;
BYTE myTexture[256 * 256 * 3];


void Init( void );
void Run( void );
void Deinit( void );
int main( int argc, char *argv[])
{
	Init();
	Run();
	Deinit();
	return 0;
}

void Init( void )
{
	SDL_Init(SDL_INIT_VIDEO);

	SDL_SetVideoMode(800, 600, 0, SDL_OPENGL | SDL_HWSURFACE);
	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 32);

    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 }; // 1 1 1 1
    GLfloat mat_shininess[] = { 50.0 }; // 50
    GLfloat light_position[] = { 2.0, 1.0, 1.0, 0.0 };

    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    //spelar ingen roll vilken ordning de är i
    glViewport (0, 0, 800, 600);
    GLfloat global_ambient[] = { 0.2f, 0.2f, 0.2f, 1.0f };
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
    glShadeModel(GL_SMOOTH);					// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);					// Black Background
    glClearDepth(1.0f);						// Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);						// Enables Depth Testing
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
	glEnable(GL_COLOR_MATERIAL);
    glDepthFunc(GL_LEQUAL);							// The Type Of Depth Testing To Do
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);			// Really Nice Perspective Calculations
	
	glMatrixMode (GL_PROJECTION); //ändrar vilken matrice som blir påverkad
	glFrustum (-1.0, 1.0, -1.0, 1.0, 1.5, 100.0);
	glMatrixMode (GL_MODELVIEW); //ändrar vilken matrice som blir påverkad

	// 2D
	glGenTextures( 1, &texture );
	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	glBindTexture(GL_TEXTURE_2D, texture);

	for( int i(0), j(0); i < 256*256*3; i++,j++ )
	{
		if( j == 3)
			j = 0;

		// Röd
		if( j == 0 )
			myTexture[i] = 250;
		// Grön
		if( j == 1 )
			myTexture[i] = 0;
		// Blå
		if( j == 2 )
			myTexture[i] = 0;
	}

	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);	// Linear Filtering
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);	// Linear Filterin

	glTexImage2D(GL_TEXTURE_2D, 0, 3, 256, 256, 0, GL_RGB, GL_UNSIGNED_BYTE, &myTexture);
}

void Deinit( void )
{
	// guess what
}

void Input( void );
void Update( void );
void Draw( void );
void Run( void )
{
	time = SDL_GetTicks();
	secondTime = SDL_GetTicks();
	while( !done )
	{
		while( time + 10 > secondTime)
		{
			SDL_Delay(1);
			secondTime = SDL_GetTicks();
		}

		Input();
		Update();
		Draw();
		time = SDL_GetTicks();
	}
}

void Input( void )
{
	static bool inputW = false;
	static bool inputA = false;
	static bool inputS = false;
	static bool inputD = false;

	static bool inputR = false;
	static bool inputE = false;

	static bool inputMouseLeft = false;

	SDL_Event event;
	while( SDL_PollEvent(&event) )
    {
		if(event.key.keysym.sym == SDLK_ESCAPE)
            done = true;

        if(event.key.keysym.sym == SDLK_w )
            inputW ? inputW = false : inputW = true;
        if(event.key.keysym.sym == SDLK_a )
            inputA ? inputA = false : inputA = true;
        if(event.key.keysym.sym == SDLK_s )
            inputS ? inputS = false : inputS = true;
        if(event.key.keysym.sym == SDLK_d )
            inputD ? inputD = false : inputD = true;

		if( event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_r )
            inputR = true;
		if(event.key.keysym.sym == SDLK_e )
            inputE ? inputE = false : inputE = true;

		if( event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT )
            inputMouseLeft = true;
	}

	if( inputW );
	if( inputA );
	if( inputS );
	if( inputD );

	if( inputR );
	if( inputE );

	if( inputMouseLeft == true )
	{
		inputMouseLeft = false;
	}
}

void Draw( void )
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glLoadIdentity();

/*	glTranslatef( cubes[0].x , cubes[0].y ,  cubes[0].z );
	glRotatef( cubes[CAMERA].rotationX, 1.0, 0.0, 0.0 );
	glRotatef( cubes[CAMERA].rotationY, 0.0, 1.0, 0.0 );
	glRotatef( cubes[CAMERA].rotationZ, 0.0, 0.0, 1.0 ); */

	// 2D
	glLoadIdentity();
	glEnable( GL_TEXTURE_2D );
	glDisable( GL_LIGHTING );

	glBindTexture( GL_TEXTURE_2D, texture );

	glTranslatef( -1.0, 1.0, -5.0 );

	glBegin(GL_QUADS);
		// Front Face
		glTexCoord2f(0.0f, 0.0f); glVertex3f(-0.2f, -0.2f,  0.2f);	// Bottom Left Of The Texture and Quad
		glTexCoord2f(1.0f, 0.0f); glVertex3f( 0.2f, -0.2f,  0.2f);	// Bottom Right Of The Texture and Quad
		glTexCoord2f(1.0f, 1.0f); glVertex3f( 0.2f,  0.2f,  0.2f);	// Top Right Of The Texture and Quad
		glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.2f,  0.2f,  0.2f);	// Top Left Of The Texture and Quad	
	glEnd();

	glDisable( GL_TEXTURE_2D );
	glEnable( GL_LIGHTING );

	SDL_GL_SwapBuffers();
}

void Update( void )
{
}
